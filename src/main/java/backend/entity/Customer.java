package backend.entity;

import backend.file_io.CredentialsFileIO;
import backend.file_io.CustomerFileIO;
import backend.file_io.OrderFileIO;
import backend.notification.CustomerNotification;
import backend.notification.DeliveryRunnerNotification;
import backend.notification.VendorNotification;
import backend.utility.Utility;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Class {@code Customer} represents the customers of the food stall who uses the system.
 *
 * @author Beng Rhui (TP068495)
 */
public class Customer extends User {

    /**
     * Attributes of the {@code Customer} class.<br>
     * An ArrayList that contains all instances of {@code Customer} is also included.
     */
    private final static ArrayList<Customer> customerList = new ArrayList<>();
    private String contactNumber;
    private Address address;
    private double eWalletAmount;
    private String deliveryNote;
    private Map<String, Integer> cart = new HashMap<>();

    /**
     * Constructor used to instantiate the {@code Customer} class.
     *
     * @param userID        The Customer ID of the user
     * @param email         The email that the customer uses to log into the account
     * @param password      The password used to log into the system
     * @param name          The real-world name of customer
     * @param contactNumber The phone number used to contact the customer
     * @param address       The delivery address of the customer
     * @param eWalletAmount The balance of e-wallet of customer
     * @param deliveryNote  The notes that a customer wishes to tell runner during delivery
     */
    public Customer(String userID, String email, String password, String name, String contactNumber,
                    Address address, double eWalletAmount, String deliveryNote) {
        super(userID, email, password, name);
        this.contactNumber = contactNumber;
        this.address = address;
        this.eWalletAmount = eWalletAmount;
        this.deliveryNote = deliveryNote;
    }

    /**
     * A method to retrieve the overall list of customers
     *
     * @return An ArrayList containing all {@code Customer} objects
     */
    public static ArrayList<Customer> getCustomerList() {
        return customerList;
    }

    /**
     * A method to add {@code Customer} objects to an overall list
     *
     * @param customer {@code Customer} objects to be added to the list
     */
    public static void addToCustomerList(Customer... customer) {

        // Throws an error if there is no customer passed into the argument, or a null customer is passed into argument
        if (customer.length == 0 || Arrays.stream(customer).anyMatch(Objects::isNull)) {
            throw new IllegalArgumentException("Arguments should contain at least one Customer object");
        }

        // Add all the customers from the arguments into the list
        customerList.addAll(
                Arrays.asList(customer)
        );
    }

    /**
     * A method to retrieve {@code Customer} based on customer ID.
     *
     * @param customerID The ID of the customer
     * @return The {@code Customer} object associated with the ID
     */
    public static Customer getCustomer(String customerID) {

        // Loop through the list of customers
        for (Customer customer : customerList) {

            // Continue the loop if the ID does not match
            if (!customer.userID.equals(customerID)) {
                continue;
            }

            // Return customer object if the ID matches
            return customer;
        }

        // If no ID matches, return null
        return null;
    }

    /**
     * A method to generate new ID for customers.
     *
     * @return THe new ID generated
     */
    public static String generateNewID() {

        // Declare variables to record index
        int index = 1;

        // Start a loop
        while (true) {

            // Get the generated ID
            String generatedID = String.format("C%03d", index);

            // Check if the generated ID is in the customer list
            boolean generatedIDExists = customerList.stream()                       // Get the list of customers
                    .anyMatch(customer -> customer.userID.equals(generatedID));     // Check if there is any match with the existing customer ID

            // If the ID does not exist among the customer list, return that ID
            if (!generatedIDExists) return generatedID;

            // Increment the index if there is a match
            index++;
        }
    }

    /**
     * A method to create new customer accounts from the admin side.
     *
     * @param customerID      The new ID of the customer (will be autogenerated)
     * @param customerName    The name of the customer
     * @param contactNumber   The contact number of the customer
     * @param addressLine1    The first address line of customer, typically includes house / unit number and street name
     * @param addressLine2    The second address line of customer, typically includes the residential area
     * @param postcode        The postcode of customer's address
     * @param state           The state of customer's address (in terms of Malaysia)
     * @param city            The city where the customer is located at
     * @param email           The email of the customer
     * @param password        The password of the customer
     * @param confirmPassword The password retyped
     * @return {@code 1} if the new account is created successfully<br>
     * {@code 0} if there exist empty values (except those being checked later)<br>
     * {@code -1} if the email is not in the correct format<br>
     * {@code -2} if the email is not available<br>
     * {@code -3} if the password does not meet requirement<br>
     * {@code -4} if the password does not match with "confirm password"<br>
     * {@code -5} if the contact number is not in the correct format
     */
    public static int createNewCustomer(
            String customerID,
            String customerName,
            String contactNumber,
            String addressLine1,
            String addressLine2,
            String postcode,
            String state,
            String city,
            String email,
            char[] password,
            char[] confirmPassword) {

        // Check if there is any empty values
        if (customerName.equalsIgnoreCase("Enter Name Here") ||
                contactNumber.equalsIgnoreCase("Contact Number Here (e.g. 012-3456789)") ||
                addressLine1.equalsIgnoreCase("Address Line 1") ||
                addressLine2.equalsIgnoreCase("Address Line 2") ||
                postcode.equalsIgnoreCase("Postcode") ||
                state == null ||
                city.equalsIgnoreCase("City") ||
                email.equalsIgnoreCase("Enter Email Here") ||
                Utility.generateString(password).equalsIgnoreCase("Enter Password Here") ||
                Utility.generateString(confirmPassword).equalsIgnoreCase("Retype Password Here")
        ) return 0;

        // Check if email is in the correct format (-1)
        boolean isEmailFormatCorrect = checkEmailFormat(email);
        if (!isEmailFormatCorrect) return -1;

        // Check if email is used by other users (-2)
        boolean isEmailUsed = isEmailAvailable(email);
        if (!isEmailUsed) return -2;

        // Check if password matches requirement (-3)
        boolean isPasswordValid = validatePassword(
                Utility.generateString(password)
        );
        if (!isPasswordValid) return -3;

        // Check if password matches (-4)
        if (!Arrays.equals(password, confirmPassword)) return -4;

        // Check if contact number is in the correct format (-5)
        boolean isContactNumberCorrect = checkContactNumberFormat(contactNumber);
        if (!isContactNumberCorrect) return -5;

        // Create address if all validation is passed
        Address newCustomerAddress = new Address(
                addressLine1,
                addressLine2,
                postcode,
                city,
                Address.State.getFromString(state)
        );

        // Create new customer object
        Customer newCustomer = new Customer(
                customerID,
                email,
                Utility.generateString(password),
                customerName,
                contactNumber,
                newCustomerAddress,
                0,
                "-"
        );

        // Add the new customer into the customer array list
        addToCustomerList(newCustomer);

        // Write into file
        CustomerFileIO customerIO = new CustomerFileIO();
        customerIO.writeFile();
        CredentialsFileIO.writeCredentialsFile();

        // Return 1 for successful creation
        return 1;
    }

    /**
     * A method to modify the existing details of a customer
     *
     * @param customerName    The name of the customer
     * @param contactNumber   The contact number of the customer
     * @param addressLine1    The first address line of customer, typically includes house / unit number and street name
     * @param addressLine2    The second address line of customer, typically includes the residential area
     * @param postcode        The postcode of customer's address
     * @param state           The state of customer's address (in terms of Malaysia)
     * @param city            The city where the customer is located at
     * @param email           The email of the customer
     * @param password        The password of the customer
     * @param confirmPassword The password retyped
     * @return {@code 1} if the new account is modified successfully<br>
     * {@code 0} if there exist any empty values (except the ones being checked later)<br>
     * {@code -1} if the email is not in the correct format<br>
     * {@code -2} if the email is not available<br>
     * {@code -3} if the password does not meet requirement<br>
     * {@code -4} if the password does not match with "confirm password"<br>
     * {@code -5} if the contact number is not in the correct format<br>
     * {@code -6} if the notification is created unsuccessfully
     */
    public int modifyCustomer(
            String customerName,
            String contactNumber,
            String addressLine1,
            String addressLine2,
            String postcode,
            String state,
            String city,
            String email,
            char[] password,
            char[] confirmPassword) {

        // Check if there is any empty values
        if (customerName.equalsIgnoreCase("Enter Name Here") ||
                contactNumber.equalsIgnoreCase("Contact Number Here (e.g. 012-3456789)") ||
                addressLine1.equalsIgnoreCase("Address Line 1") ||
                addressLine2.equalsIgnoreCase("Address Line 2") ||
                postcode.equalsIgnoreCase("Postcode") ||
                state == null ||
                city.equalsIgnoreCase("City") ||
                email.equalsIgnoreCase("Enter Email Here") ||
                Utility.generateString(password).equalsIgnoreCase("Enter Password Here") ||
                Utility.generateString(confirmPassword).equalsIgnoreCase("Retype Password Here")
        ) return 0;

        // Check if email is in the correct format (-1)
        if (!checkEmailFormat(email)) return -1;

        // Check if email is available (for different email) (-2)
        if (!email.equals(this.email) && !isEmailAvailable(email)) return -2;

        // Check if password meets requirement (-3)
        if (!validatePassword(
                Utility.generateString(password)
        )) return -3;

        // Check if both passwords match (-4)
        if (!Arrays.equals(password, confirmPassword)) return -4;

        // Check if contact number is in the correct format (-5)
        if (!checkContactNumberFormat(contactNumber)) return -5;

        // Create address
        Address newCustomerAddress = new Address(
                addressLine1,
                addressLine2,
                postcode,
                city,
                Address.State.getFromString(state)
        );

        // Create notification to update customer
        boolean notificationCreated = CustomerNotification.createNewNotification(
                "Updated Personal Information",
                "Your personal information has been updated successfully.",
                this
        );
        if (!notificationCreated) return -6;

        // Update every detail of the customer
        this.setName(customerName);
        this.setContactNumber(contactNumber);
        this.setAddress(newCustomerAddress);
        this.setEmail(email);
        this.setPassword(
                Utility.generateString(password)
        );

        // Write into file (notification will be automatically written to file)
        CustomerFileIO customerIO = new CustomerFileIO();
        customerIO.writeFile();
        CredentialsFileIO.writeCredentialsFile();

        // Return 1 if modification is made successfully
        return 1;
    }

    /**
     * A method to delete a customer account from system.
     *
     * @return {@code true} if customer is deleted successfully, else {@code false}
     */
    public boolean deleteCustomer() {

        // Delete notifications associated with the customer
        boolean deleteNotification = CustomerNotification.deleteCustomerFromNotification(this.getUserID());
        if (!deleteNotification) return false;

        // Change the customer associated with order to null (record is remained for dashboard purpose)
        boolean changeOrder = Order.changeCustomerToNull(this.getUserID());
        if (!changeOrder) return false;

        // Delete the associated transaction history
        boolean transactionDeleted = Transaction.deleteTransaction(this.getUserID());
        if (!transactionDeleted) return false;

        // Change the customer attribute for the associated feedback to null
        boolean changeFeedback = Feedback.changeCustomerToNull(this.getUserID());
        if (!changeFeedback) return false;

        // Delete user from list
        boolean removeSuccessful = getCustomerList().remove(this);
        if (!removeSuccessful) return false;

        // Write to file
        CredentialsFileIO.writeCredentialsFile();
        CustomerFileIO customerIO = new CustomerFileIO();
        customerIO.writeFile();

        // Return true if everything looks good
        return true;
    }

    /**
     * A method to top up the e-wallet amount of customer.
     *
     * @param amount        The top-up value
     * @param paymentMethod The way customer pay to admin
     * @return {@code 1} if top-up is successful<br>
     * {@code 0} if amount is less than 0<br>
     * {@code -1} if the transaction type is invalid<br>
     * {@code -2} if notification cannot be generated<br>
     * {@code -3} if transaction record cannot be generated
     */
    public int topUpWallet(double amount, String paymentMethod) {

        // Return false if amount is less than or equals to 0
        if (amount <= 0) return 0;

        // If payment method is not correct (should not happen but included for validation purpose)
        Transaction.PaymentMethod wayToPay = Transaction.PaymentMethod.getType(paymentMethod);
        if (wayToPay == null) return -1;

        // Get the initial amount
        double initialAmount = this.getEWalletAmount();

        // Calculate and set the new amount
        double topUpAmount = Math.round(amount * 100) / 100.0;

        // Create notification to inform customer about top up
        boolean createNotification = CustomerNotification.createNewNotification(
                "E-Wallet Top Up",
                "Thank you for paying using " + wayToPay + ". RM" + String.format("%.2f", topUpAmount) + " has been successfully topped up to your e-wallet.",
                this
        );
        if (!createNotification) return -2;

        // Create transaction history for customer
        boolean transactionRecordCreated = Transaction.createTransactionHistory(
                this,
                topUpAmount,
                Transaction.TransactionType.CASH_IN,
                wayToPay
        );
        if (!transactionRecordCreated) return -3;

        // Set the new amount
        this.setEWalletAmount(initialAmount + topUpAmount);

        // Write changes to file
        CustomerFileIO customerIO = new CustomerFileIO();
        customerIO.writeFile();

        // Return true for successful operation
        return 1;
    }

    /**
     * Getters and setters for the {@code Customer} class
     */
    public String getContactNumber() {
        return contactNumber;
    }

    public void setContactNumber(String contactNumber) {
        this.contactNumber = contactNumber;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public double getEWalletAmount() {
        return eWalletAmount;
    }

    public void setEWalletAmount(double eWalletAmount) {
        this.eWalletAmount = eWalletAmount;
    }

    public String getDeliveryNote() {
        return deliveryNote;
    }

    public void setDeliveryNote(String deliveryNote) {
        this.deliveryNote = deliveryNote;
    }

    public Map<String, Integer> getCart() {
        return cart;
    }

    public void setCart(Map<String, Integer> cart) {
        this.cart = cart;
    }

    /**
     * A method to update the items in the cart.
     *
     * @param item     The item object that is added to cart
     * @param quantity The quantity of items
     * @return {@code true} if the cart is updated successfully, else {@code false}
     */
    public boolean addItemToCart(Item item, int quantity) {

        // Return false if the inputs are null
        if (item == null || quantity <= 0) return false;

        // Get the ID of the item
        String itemID = item.getItemID();

        // If the item ID is already in the list, add the quantity
        if (cart.containsKey(itemID)) {

            // Get the initial quantity and replace the existing value
            int newQuantity = cart.get(itemID) + quantity;
            cart.replace(itemID, newQuantity);

        } else {

            // If the ID is not in list, add the new key value to the map
            cart.put(item.getItemID(), quantity);
        }

        // Return true for successful operation
        return true;
    }

    /**
     * A method to allow customers to remove an item from their cart.
     *
     * @param item The item to be removed
     * @return {@code true} if the item is removed successfully, else false
     */
    public boolean removeItemFromCart(Item item) {

        // Return false if the input is null
        if (item == null || cart.isEmpty()) return false;

        // Get the ID of the item
        String itemID = item.getItemID();

        // Remove the item from the cart and return true for successful operation
        return cart.remove(itemID) != null;
    }

    /**
     * A method to clear customer cart.
     */
    public void clearCustomerCart() {

        // Clear the map associated with the cart
        cart.clear();
    }

    /**
     * A method for customers to update cart based on the chosen dining method.
     *
     * @param diningType The dining type preferred by customers
     * @return {@code true} if the cart is updated, else {@code false}
     */
    public boolean setDiningMethodInCart(Order.DiningType diningType) {

        // If the input is null, return false
        if (diningType == null) return false;

        // Compute based on different dining type
        switch (diningType) {

            // If the dining type is delivery, then the delivery fees has to be included
            case DELIVERY -> cart.putIfAbsent(Item.deliveryFees.getItemID(), 1);

            // If the dining type is dine-in or takeaway, delivery fees should not be there
            case DINE_IN, TAKEAWAY -> {
                if (cart.get(Item.deliveryFees.getItemID()) != null) cart.remove(Item.deliveryFees.getItemID());
            }
        }

        // Return true for successful operation
        return true;
    }

    /**
     * A method for customers to place an order.
     *
     * @param stall         The stall associated with the cart
     * @param cart          The items inside the cart
     * @param diningType    The dining method chosen by customer
     * @param notesToVendor The additional notes provided to vendor
     * @param tableNumber   The table number inputted by customer (only for dine-in)
     * @return {@code 1} if the order is placed successfully<br>
     * {@code 0} if the cart is empty<br>
     * {@code -1} if the amount is less than the vendor's e-wallet<br>
     * {@code -2} if runner is not available for delivery<br>
     * {@code -3} if notifications fail to be created<br>
     * {@code -4} if transaction history fails to be created<br>
     * {@code -5} if dining type is not provided
     */
    public int placeOrder(Stall stall, Map<String, Integer> cart, Order.DiningType diningType, String notesToVendor, String tableNumber) {

        // If the cart is empty, reject placing order
        if (cart.isEmpty() || (cart.size() == 1 && cart.containsKey(Item.deliveryFees.getItemID()))) return 0;

        // If the wallet balance is less than the order amount, return fail code
        if (Utility.getTotalAmountForCart(cart) > this.eWalletAmount) return -1;

        // If dining type is null, return fail code
        if (diningType == null) return -5;

        // Declare a variable to store runner involved (for delivery)
        DeliveryRunner runnerGenerated = null;

        // Check if dining type is delivery
        if (diningType == Order.DiningType.DELIVERY) {

            // Try to get an available runner if possible
            runnerGenerated = DeliveryRunner.getAvailableRunner();

            // If there is no runner available, reject the order
            if (runnerGenerated == null) return -2;
        }

        // Create new order
        Order newOrder = new Order(
                Order.generateNewID(),
                this,
                stall,
                runnerGenerated,
                null,
                diningType,
                tableNumber,
                notesToVendor,
                Utility.getTotalAmountForCart(cart),
                LocalDateTime.now(),
                Order.OrderStatus.WAITING_VENDOR,
                Utility.convertItemMap(cart)
        );

        // Create customer notification for new order
        boolean createCustomerNotification = CustomerNotification.createNewNotification(
                "Order Placed Successfully",
                "Your order " + newOrder.getOrderID() + " has been created successfully. " +
                        "An amount of RM" + String.format("%.2f", Utility.getTotalAmountForCart(cart)) + " is deducted from your wallet. " +
                        "Please wait for the vendor and runner (if applicable) to accept your order.",
                this
        );
        if (!createCustomerNotification) return -3;

        // Create vendor notification for new order
        boolean createVendorNotification = VendorNotification.createNewNotification(
                "New Order Available",
                "A new order with ID " + newOrder.getOrderID() + " is available. You may return to the main menu to check the details.",
                stall
        );
        if (!createVendorNotification) return -3;

        // Create runner notification for new order (if involved)
        if (runnerGenerated != null) {
            boolean createRunnerNotification = DeliveryRunnerNotification.createNewNotification(
                    "New Order Available",
                    "A new order with ID " + newOrder.getOrderID() + " is available. You may return to the main menu to check the details.",
                    runnerGenerated
            );
            if (!createRunnerNotification) return -3;
        }

        // Remove the money from the customer's account
        double remainingWalletAmount = this.getEWalletAmount() - Utility.getTotalAmountForCart(cart);
        this.setEWalletAmount(remainingWalletAmount);

        // Create a transaction history to record the money spent on order
        boolean createTransactionHistory = Transaction.createTransactionHistory(
                this,
                Utility.getTotalAmountForCart(cart),
                Transaction.TransactionType.CASH_OUT,
                Transaction.PaymentMethod.E_WALLET
        );
        if (!createTransactionHistory) return -4;

        // Add to order list
        Order.addToOrderList(newOrder);

        // Write to file
        OrderFileIO.writeFile();
        CustomerFileIO customerIO = new CustomerFileIO();
        customerIO.writeFile();

        // Reset cart
        this.setCart(new HashMap<>());

        // Return true for successful operation
        return 1;
    }

    /**
     * A method to set the address and delivery notes for customers.
     *
     * @param addressLine1 The new address line 1 for customer
     * @param addressLine2 The new address line 2 for customer
     * @param postcode     The postcode for the address
     * @param state        The state for the address
     * @param city         The city for the address
     * @param deliveryNote The delivery note that customer wishes to tell to runner
     * @return {@code true} if the address is updated sccessfully, else {@code false}
     */
    public boolean modifyAddressAndDeliveryNotes(
            String addressLine1,
            String addressLine2,
            String postcode,
            Address.State state,
            String city,
            String deliveryNote
    ) {

        // If inputs are null or empty, then reject
        if (addressLine1.equalsIgnoreCase("Address Line 1") || addressLine1.isBlank() ||
                addressLine2.equalsIgnoreCase("Address Line 2") || addressLine2.isBlank() ||
                postcode.equalsIgnoreCase("Postcode") || postcode.isBlank() ||
                state == null ||
                city.equalsIgnoreCase("City") || city.isBlank() ||
                deliveryNote.equalsIgnoreCase("Delivery Note") || deliveryNote.isBlank()
        ) return false;

        // Retrieve the initial address of customer
        Address customerAddress = this.getAddress();

        // Update the address
        customerAddress.setAddressLine1(addressLine1);
        customerAddress.setAddressLine2(addressLine2);
        customerAddress.setPostcode(postcode);
        customerAddress.setCity(city);
        customerAddress.setState(state);

        // Update delivery note for customer
        this.setDeliveryNote(deliveryNote);

        // Update into file
        CustomerFileIO customerIO = new CustomerFileIO();
        customerIO.writeFile();

        // Return true for successful operation
        return true;
    }

    /**
     * A method to calculate the total cash in for a customer.
     *
     * @return The total cash in amount
     */
    public double calculateTotalCashIn() {

        // Get the list of transactions
        ArrayList<Transaction> transactionList = Transaction.getTransactionList(this);

        // Filter the transaction list so that only cash in transactions are involved
        transactionList = transactionList.stream()
                .filter(transaction -> transaction.getTransactionType() == Transaction.TransactionType.CASH_IN)
                .collect(Collectors.toCollection(ArrayList::new));

        // Declare an empty variable to store cash in
        double cashInAmount = 0;

        // Loop through the transaction list
        for (Transaction transaction : transactionList) cashInAmount += transaction.getTransactionAmount();

        // Return the cash in amount
        return cashInAmount;
    }

    /**
     * A method to calculate the total cash out for a customer.
     *
     * @return The total cash out amount
     */
    public double calculateTotalCashOut() {

        // Get the list of transactions
        ArrayList<Transaction> transactionList = Transaction.getTransactionList(this);

        // Filter the transaction list so that only cash in transactions are involved
        transactionList = transactionList.stream()
                .filter(transaction -> transaction.getTransactionType() == Transaction.TransactionType.CASH_OUT)
                .collect(Collectors.toCollection(ArrayList::new));

        // Declare an empty variable to store cash out
        double cashOutAmount = 0;

        // Loop through the transaction list
        for (Transaction transaction : transactionList) cashOutAmount += transaction.getTransactionAmount();

        // Return the cash in amount
        return cashOutAmount;
    }

    /**
     * A method to print out the information of {@code Customer} instances.
     *
     * @return String representation of {@code Customer} object
     */
    @Override
    public String toString() {
        return "Customer ID: " + super.userID + "\n" +
                "Customer Email: " + super.email + "\n" +
                "Customer Password: " + super.password + "\n" +
                "Customer Name: " + super.name + "\n" +
                "Customer Contact No: " + contactNumber + "\n" +
                "Customer Address: " + "\n" +
                address.toString() + "\n" +
                "Customer E-Wallet Amount: " + eWalletAmount + "\n" +
                "Customer Delivery Note: " + deliveryNote;
    }
}
